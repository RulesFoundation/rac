"""JavaScript code generator.

Compiles IR to standalone JavaScript that works in browsers and Node.js.
"""

from .. import ast
from ..compiler import IR


def generate_javascript(ir: IR, module_name: str = "calculator") -> str:
    """Generate JavaScript code from IR."""
    gen = JavaScriptGenerator(ir, module_name)
    return gen.generate()


class JavaScriptGenerator:
    """Generates JavaScript code from compiled IR."""

    def __init__(self, ir: IR, module_name: str):
        self.ir = ir
        self.module_name = module_name
        self.entity_vars: dict[str, list[str]] = {}
        for path in ir.order:
            var = ir.variables[path]
            if var.entity:
                self.entity_vars.setdefault(var.entity, []).append(path)

    def generate(self) -> str:
        lines = [
            "// Auto-generated by RAC compiler",
            "",
        ]

        # Entity input classes
        for entity in self.ir.schema_.entities.values():
            lines.extend(self._gen_input_class(entity))
            lines.append("")

        # Compute scalars function
        lines.extend(self._gen_compute_scalars())
        lines.append("")

        # Compute entity functions
        for entity_name in self.entity_vars:
            lines.extend(self._gen_compute_entity(entity_name))
            lines.append("")

        return "\n".join(lines)

    def _gen_input_class(self, entity) -> list[str]:
        lines = [
            f"class {self._js_class_name(entity.name)}Input {{",
            "  constructor(data) {",
        ]
        for name in entity.fields:
            safe = self._js_ident(name)
            lines.append(f"    this.{safe} = data.{safe};")
        lines.append("  }")
        lines.append("}")
        return lines

    def _gen_compute_scalars(self) -> list[str]:
        lines = [
            "function computeScalars() {",
        ]

        scalar_names = []
        for path in self.ir.order:
            var = self.ir.variables[path]
            if var.entity is None:
                safe_name = self._js_ident(path.replace("/", "_"))
                expr_code = self._gen_expr(var.expr)
                lines.append(f"  const {safe_name} = {expr_code};")
                scalar_names.append(safe_name)

        lines.append("  return {")
        for name in scalar_names:
            lines.append(f"    {name},")
        lines.append("  };")
        lines.append("}")
        return lines

    def _gen_compute_entity(self, entity_name: str) -> list[str]:
        func_name = f"compute{self._js_class_name(entity_name)}"
        var_paths = self.entity_vars[entity_name]

        lines = [
            f"function {func_name}(input, scalars) {{",
        ]

        computed_names = []
        for path in var_paths:
            safe_name = self._js_ident(path.replace("/", "_"))
            var = self.ir.variables[path]
            expr_code = self._gen_expr(
                var.expr, entity_var="input", scalars_var="scalars", computed=computed_names.copy()
            )
            lines.append(f"  const {safe_name} = {expr_code};")
            computed_names.append((path, safe_name))

        lines.append("  return {")
        for _, name in computed_names:
            lines.append(f"    {name},")
        lines.append("  };")
        lines.append("}")
        return lines

    def _gen_expr(
        self,
        expr: ast.Expr,
        entity_var: str | None = None,
        scalars_var: str | None = None,
        computed: list[tuple[str, str]] | None = None,
    ) -> str:
        computed = computed or []
        computed_lookup = dict(computed)

        match expr:
            case ast.Literal(value=v):
                if isinstance(v, bool):
                    return "true" if v else "false"
                if isinstance(v, str):
                    return f'"{v}"'
                return str(v)

            case ast.Var(path=path):
                if path in computed_lookup:
                    return computed_lookup[path]
                if "/" in path:
                    safe = self._js_ident(path.replace("/", "_"))
                    if scalars_var:
                        return f"{scalars_var}.{safe}"
                    return safe
                if entity_var:
                    return f"{entity_var}.{self._js_ident(path)}"
                return self._js_ident(path)

            case ast.BinOp(op=op, left=left, right=right):
                left_val = self._gen_expr(left, entity_var, scalars_var, computed)
                right_val = self._gen_expr(right, entity_var, scalars_var, computed)
                js_op = self._js_op(op)
                return f"({left_val} {js_op} {right_val})"

            case ast.UnaryOp(op=op, operand=operand):
                inner = self._gen_expr(operand, entity_var, scalars_var, computed)
                if op == "-":
                    return f"(-{inner})"
                if op == "not":
                    return f"(!{inner})"
                return inner

            case ast.Call(func=func, args=args):
                arg_strs = [self._gen_expr(a, entity_var, scalars_var, computed) for a in args]
                return self._gen_builtin_call(func, arg_strs)

            case ast.FieldAccess(obj=obj, field=field):
                obj_code = self._gen_expr(obj, entity_var, scalars_var, computed)
                return f"{obj_code}.{self._js_ident(field)}"

            case ast.Cond(condition=cond, then_expr=then_e, else_expr=else_e):
                c = self._gen_expr(cond, entity_var, scalars_var, computed)
                t = self._gen_expr(then_e, entity_var, scalars_var, computed)
                e = self._gen_expr(else_e, entity_var, scalars_var, computed)
                return f"({c} ? {t} : {e})"

            case ast.Match(subject=subject, cases=cases, default=default):
                return self._gen_match(subject, cases, default, entity_var, scalars_var, computed)

            case _:
                return "0"

    def _gen_match(
        self,
        subject: ast.Expr,
        cases: list[tuple[ast.Expr, ast.Expr]],
        default: ast.Expr | None,
        entity_var: str | None,
        scalars_var: str | None,
        computed: list[tuple[str, str]] | None,
    ) -> str:
        subj = self._gen_expr(subject, entity_var, scalars_var, computed)
        # Build nested ternary
        result = (
            "0" if default is None else self._gen_expr(default, entity_var, scalars_var, computed)
        )
        for pattern, value in reversed(cases):
            p = self._gen_expr(pattern, entity_var, scalars_var, computed)
            v = self._gen_expr(value, entity_var, scalars_var, computed)
            result = f"({subj} === {p} ? {v} : {result})"
        return result

    def _gen_builtin_call(self, func: str, args: list[str]) -> str:
        match func:
            case "min":
                return f"Math.min({', '.join(args)})"
            case "max":
                return f"Math.max({', '.join(args)})"
            case "abs":
                return f"Math.abs({args[0]})"
            case "round":
                return f"Math.round({args[0]})"
            case "sum":
                return f"{args[0]}.reduce((a, b) => a + b, 0)"
            case "len":
                return f"{args[0]}.length"
            case "clip":
                return f"Math.min(Math.max({args[0]}, {args[1]}), {args[2]})"
            case _:
                return f"/* unknown: {func} */ 0"

    def _js_op(self, op: str) -> str:
        return {
            "and": "&&",
            "or": "||",
            "==": "===",
            "!=": "!==",
        }.get(op, op)

    def _js_ident(self, name: str) -> str:
        name = name.replace("-", "_").replace(".", "_")
        if name in (
            "class",
            "function",
            "var",
            "let",
            "const",
            "return",
            "new",
            "delete",
            "typeof",
            "in",
        ):
            return f"_{name}"
        return name

    def _js_class_name(self, name: str) -> str:
        return "".join(part.capitalize() for part in name.split("_"))

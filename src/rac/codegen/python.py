"""Python code generator.

Compiles IR to standalone Python source code.
"""

from .. import ast
from ..compiler import IR


def generate_python(ir: IR, module_name: str = "calculator") -> str:
    """Generate Python code from IR."""
    gen = PythonGenerator(ir, module_name)
    return gen.generate()


class PythonGenerator:
    """Generates Python code from compiled IR."""

    def __init__(self, ir: IR, module_name: str):
        self.ir = ir
        self.module_name = module_name
        self.entity_vars: dict[str, list[str]] = {}
        for path in ir.order:
            var = ir.variables[path]
            if var.entity:
                self.entity_vars.setdefault(var.entity, []).append(path)

    def generate(self) -> str:
        lines = [
            '"""Auto-generated by RAC compiler."""',
            "",
            "from dataclasses import dataclass",
            "",
        ]

        # Entity input dataclasses
        for entity in self.ir.schema_.entities.values():
            lines.extend(self._gen_input_class(entity))
            lines.append("")

        # Compute scalars function
        lines.extend(self._gen_compute_scalars())
        lines.append("")

        # Compute entity functions
        for entity_name in self.entity_vars:
            lines.extend(self._gen_compute_entity(entity_name))
            lines.append("")

        return "\n".join(lines)

    def _gen_input_class(self, entity) -> list[str]:
        lines = [
            "@dataclass",
            f"class {self._py_class_name(entity.name)}Input:",
        ]
        if not entity.fields:
            lines.append("    pass")
        else:
            for name, field in entity.fields.items():
                py_type = self._field_type(field.dtype)
                lines.append(f"    {self._py_ident(name)}: {py_type}")
        return lines

    def _gen_compute_scalars(self) -> list[str]:
        lines = [
            "def compute_scalars():",
        ]

        scalar_names = []
        has_scalars = False
        for path in self.ir.order:
            var = self.ir.variables[path]
            if var.entity is None:
                safe_name = self._py_ident(path.replace("/", "_"))
                expr_code = self._gen_expr(var.expr)
                lines.append(f"    {safe_name} = {expr_code}")
                scalar_names.append(safe_name)
                has_scalars = True

        if not has_scalars:
            lines.append("    pass")

        lines.append("    return {")
        for name in scalar_names:
            lines.append(f'        "{name}": {name},')
        lines.append("    }")
        return lines

    def _gen_compute_entity(self, entity_name: str) -> list[str]:
        func_name = f"compute_{entity_name}"
        var_paths = self.entity_vars[entity_name]

        lines = [
            f"def {func_name}(input_data, scalars):",
        ]

        computed_names = []
        for path in var_paths:
            safe_name = self._py_ident(path.replace("/", "_"))
            var = self.ir.variables[path]
            expr_code = self._gen_expr(
                var.expr,
                entity_var="input_data",
                scalars_var="scalars",
                computed=computed_names.copy(),
            )
            lines.append(f"    {safe_name} = {expr_code}")
            computed_names.append((path, safe_name))

        lines.append("    return {")
        for _, name in computed_names:
            lines.append(f'        "{name}": {name},')
        lines.append("    }")
        return lines

    def _gen_expr(
        self,
        expr: ast.Expr,
        entity_var: str | None = None,
        scalars_var: str | None = None,
        computed: list[tuple[str, str]] | None = None,
    ) -> str:
        computed = computed or []
        computed_lookup = dict(computed)

        match expr:
            case ast.Literal(value=v):
                if isinstance(v, bool):
                    return "True" if v else "False"
                if isinstance(v, str):
                    return f'"{v}"'
                return repr(v)

            case ast.Var(path=path):
                if path in computed_lookup:
                    return computed_lookup[path]
                if "/" in path:
                    safe = self._py_ident(path.replace("/", "_"))
                    if scalars_var:
                        return f'{scalars_var}["{safe}"]'
                    return safe
                if entity_var:
                    return f"{entity_var}.{self._py_ident(path)}"
                return self._py_ident(path)

            case ast.BinOp(op=op, left=left, right=right):
                left_val = self._gen_expr(left, entity_var, scalars_var, computed)
                right_val = self._gen_expr(right, entity_var, scalars_var, computed)
                py_op = self._py_op(op)
                return f"({left_val} {py_op} {right_val})"

            case ast.UnaryOp(op=op, operand=operand):
                inner = self._gen_expr(operand, entity_var, scalars_var, computed)
                if op == "-":
                    return f"(-{inner})"
                if op == "not":
                    return f"(not {inner})"
                return inner

            case ast.Call(func=func, args=args):
                arg_strs = [self._gen_expr(a, entity_var, scalars_var, computed) for a in args]
                return self._gen_builtin_call(func, arg_strs)

            case ast.FieldAccess(obj=obj, field=field):
                obj_code = self._gen_expr(obj, entity_var, scalars_var, computed)
                return f"{obj_code}.{self._py_ident(field)}"

            case ast.Cond(condition=cond, then_expr=then_e, else_expr=else_e):
                c = self._gen_expr(cond, entity_var, scalars_var, computed)
                t = self._gen_expr(then_e, entity_var, scalars_var, computed)
                e = self._gen_expr(else_e, entity_var, scalars_var, computed)
                return f"({t} if {c} else {e})"

            case ast.Match(subject=subject, cases=cases, default=default):
                return self._gen_match(subject, cases, default, entity_var, scalars_var, computed)

            case _:
                return "0"

    def _gen_match(
        self,
        subject: ast.Expr,
        cases: list[tuple[ast.Expr, ast.Expr]],
        default: ast.Expr | None,
        entity_var: str | None,
        scalars_var: str | None,
        computed: list[tuple[str, str]] | None,
    ) -> str:
        subj = self._gen_expr(subject, entity_var, scalars_var, computed)
        # Build nested ternary
        result = (
            "0" if default is None else self._gen_expr(default, entity_var, scalars_var, computed)
        )
        for pattern, value in reversed(cases):
            p = self._gen_expr(pattern, entity_var, scalars_var, computed)
            v = self._gen_expr(value, entity_var, scalars_var, computed)
            result = f"({v} if {subj} == {p} else {result})"
        return result

    def _gen_builtin_call(self, func: str, args: list[str]) -> str:
        match func:
            case "min":
                return f"min({', '.join(args)})"
            case "max":
                return f"max({', '.join(args)})"
            case "abs":
                return f"abs({args[0]})"
            case "round":
                return f"round({args[0]})"
            case "sum":
                return f"sum({args[0]})"
            case "len":
                return f"len({args[0]})"
            case "clip":
                return f"min(max({args[0]}, {args[1]}), {args[2]})"
            case _:
                return f"0  # unknown: {func}"

    def _py_op(self, op: str) -> str:
        return {
            "and": "and",
            "or": "or",
        }.get(op, op)

    def _py_ident(self, name: str) -> str:
        name = name.replace("-", "_").replace(".", "_")
        if name in ("class", "def", "return", "import", "from", "global", "lambda", "pass", "in"):
            return f"_{name}"
        return name

    def _py_class_name(self, name: str) -> str:
        return "".join(part.capitalize() for part in name.split("_"))

    def _field_type(self, dtype: str) -> str:
        return {
            "int": "int",
            "float": "float",
            "str": "str",
            "bool": "bool",
            "date": "str",
        }.get(dtype, "float")

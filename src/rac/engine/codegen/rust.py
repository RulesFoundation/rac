"""Rust code generator.

Compiles IR to Rust source code that can be built with cargo.
"""

from .. import ast
from ..compiler import IR


def generate_rust(ir: IR, module_name: str = "rules") -> str:
    """Generate Rust code from IR."""
    gen = RustGenerator(ir, module_name)
    return gen.generate()


class RustGenerator:
    """Generates Rust code from compiled IR."""

    def __init__(self, ir: IR, module_name: str):
        self.ir = ir
        self.module_name = module_name
        self.indent = 0
        self.entity_vars: dict[str, list[str]] = {}
        for path in ir.order:
            var = ir.variables[path]
            if var.entity:
                if var.entity not in self.entity_vars:
                    self.entity_vars[var.entity] = []
                self.entity_vars[var.entity].append(path)

    def generate(self) -> str:
        lines = [
            "//! Auto-generated by RAC compiler",
            "",
        ]

        for entity in self.ir.schema_.entities.values():
            lines.extend(self._gen_input_struct(entity))
            lines.append("")

        for entity_name, var_paths in self.entity_vars.items():
            lines.extend(self._gen_output_struct(entity_name, var_paths))
            lines.append("")

        lines.extend(self._gen_scalars_struct())
        lines.append("")

        lines.extend(self._gen_compute_scalars())
        lines.append("")

        for entity_name in self.entity_vars:
            lines.extend(self._gen_compute_entity(entity_name))
            lines.append("")

        return "\n".join(lines)

    def _gen_input_struct(self, entity) -> list[str]:
        lines = [
            "#[derive(Debug, Clone)]",
            f"pub struct {self._rust_type_name(entity.name)}Input {{",
        ]
        for name, field in entity.fields.items():
            rust_type = self._field_type(field.dtype)
            lines.append(f"    pub {self._rust_ident(name)}: {rust_type},")
        lines.append("}")
        return lines

    def _gen_output_struct(self, entity_name: str, var_paths: list[str]) -> list[str]:
        lines = [
            "#[derive(Debug, Clone, Default)]",
            f"pub struct {self._rust_type_name(entity_name)}Output {{",
        ]
        for path in var_paths:
            safe_name = self._rust_ident(path.replace("/", "_"))
            lines.append(f"    pub {safe_name}: f64,")
        lines.append("}")
        return lines

    def _gen_scalars_struct(self) -> list[str]:
        lines = [
            "#[derive(Debug, Clone)]",
            "pub struct Scalars {",
        ]
        for path in self.ir.order:
            var = self.ir.variables[path]
            if var.entity is None:
                safe_name = self._rust_ident(path.replace("/", "_"))
                lines.append(f"    pub {safe_name}: f64,")
        lines.append("}")
        return lines

    def _gen_compute_scalars(self) -> list[str]:
        lines = [
            "impl Scalars {",
            "    pub fn compute() -> Self {",
        ]

        scalar_names = []
        for path in self.ir.order:
            var = self.ir.variables[path]
            if var.entity is None:
                safe_name = self._rust_ident(path.replace("/", "_"))
                expr_code = self._gen_expr(var.expr)
                lines.append(f"        let {safe_name} = {expr_code};")
                scalar_names.append(safe_name)

        lines.append("        Self {")
        for name in scalar_names:
            lines.append(f"            {name},")
        lines.append("        }")
        lines.append("    }")
        lines.append("}")
        return lines

    def _gen_compute_entity(self, entity_name: str) -> list[str]:
        type_name = self._rust_type_name(entity_name)
        var_paths = self.entity_vars[entity_name]

        lines = [
            f"impl {type_name}Output {{",
            "    #[inline]",
            f"    pub fn compute(input: &{type_name}Input, scalars: &Scalars) -> Self {{",
        ]

        computed_names = []
        for path in var_paths:
            safe_name = self._rust_ident(path.replace("/", "_"))
            var = self.ir.variables[path]
            expr_code = self._gen_expr(
                var.expr, entity_var="input", scalars_var="scalars", computed=computed_names.copy()
            )
            lines.append(f"        let {safe_name} = {expr_code};")
            computed_names.append((path, safe_name))

        lines.append("        Self {")
        for _, name in computed_names:
            lines.append(f"            {name},")
        lines.append("        }")
        lines.append("    }")
        lines.append("}")
        return lines

    def _gen_expr(
        self,
        expr: ast.Expr,
        entity_var: str | None = None,
        scalars_var: str | None = None,
        computed: list[tuple[str, str]] | None = None,
    ) -> str:
        computed = computed or []
        computed_lookup = {path: name for path, name in computed}

        match expr:
            case ast.Literal(value=v):
                if isinstance(v, bool):
                    return "true" if v else "false"
                if isinstance(v, str):
                    return f'"{v}"'
                if isinstance(v, float):
                    return f"{v}_f64"
                return f"{v}_f64"

            case ast.Var(path=path):
                if path in computed_lookup:
                    return computed_lookup[path]
                if "/" in path:
                    safe = self._rust_ident(path.replace("/", "_"))
                    if scalars_var:
                        return f"{scalars_var}.{safe}"
                    return safe
                if entity_var:
                    return f"{entity_var}.{self._rust_ident(path)}"
                return self._rust_ident(path)

            case ast.BinOp(op=op, left=left, right=right):
                left_val = self._gen_expr(left, entity_var, scalars_var, computed)
                right_val = self._gen_expr(right, entity_var, scalars_var, computed)
                rust_op = self._rust_op(op)
                return f"({left_val} {rust_op} {right_val})"

            case ast.UnaryOp(op=op, operand=operand):
                inner = self._gen_expr(operand, entity_var, scalars_var, computed)
                if op == "-":
                    return f"(-{inner})"
                if op == "not":
                    return f"(!{inner})"
                return inner

            case ast.Call(func=func, args=args):
                arg_strs = [self._gen_expr(a, entity_var, scalars_var, computed) for a in args]
                return self._gen_builtin_call(func, arg_strs)

            case ast.FieldAccess(obj=obj, field=field):
                obj_code = self._gen_expr(obj, entity_var, scalars_var, computed)
                return f"{obj_code}.{self._rust_ident(field)}"

            case ast.Cond(condition=cond, then_expr=then_e, else_expr=else_e):
                c = self._gen_expr(cond, entity_var, scalars_var, computed)
                t = self._gen_expr(then_e, entity_var, scalars_var, computed)
                e = self._gen_expr(else_e, entity_var, scalars_var, computed)
                return f"(if {c} {{ {t} }} else {{ {e} }})"

            case _:
                return "0.0_f64"

    def _gen_builtin_call(self, func: str, args: list[str]) -> str:
        match func:
            case "min":
                if len(args) == 2:
                    return f"{args[0]}.min({args[1]})"
                return f"[{', '.join(args)}].iter().cloned().fold(f64::INFINITY, f64::min)"
            case "max":
                if len(args) == 2:
                    return f"{args[0]}.max({args[1]})"
                return f"[{', '.join(args)}].iter().cloned().fold(f64::NEG_INFINITY, f64::max)"
            case "abs":
                return f"{args[0]}.abs()"
            case "round":
                return f"{args[0]}.round()"
            case "sum":
                return f"{args[0]}.iter().sum::<f64>()"
            case "len":
                return f"({args[0]}.len() as f64)"
            case "clip":
                return f"{args[0]}.max({args[1]}).min({args[2]})"
            case _:
                return f"/* unknown: {func} */ 0.0_f64"

    def _rust_op(self, op: str) -> str:
        return {
            "and": "&&",
            "or": "||",
            "==": "==",
            "!=": "!=",
        }.get(op, op)

    def _rust_ident(self, name: str) -> str:
        name = name.replace("-", "_").replace(".", "_")
        if name in ("type", "match", "fn", "let", "mut", "ref", "self", "super", "use"):
            return f"r#{name}"
        return name

    def _rust_type_name(self, name: str) -> str:
        return "".join(part.capitalize() for part in name.split("_"))

    def _field_type(self, dtype: str) -> str:
        return {
            "int": "i64",
            "float": "f64",
            "str": "String",
            "bool": "bool",
            "date": "String",
        }.get(dtype, "f64")
